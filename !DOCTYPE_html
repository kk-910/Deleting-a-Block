<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Falling Blocks</title>
<style>
  body { background: #111; color: white; text-align: center; }
  canvas { background: #222; display: block; margin: 1em auto; }
</style>
</head>
<body>
<h1>Falling Blocks</h1>
<canvas id="game" width="240" height="400"></canvas>
<p>← → : 移動 | ↑: 回転 | ↓: ソフトドロップ | Space: ハードドロップ</p>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const COLS = 10, ROWS = 20, BLOCK = 20;

// 盤面
let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));

// テトリミノ
const tetrominoes = {
  I: [[1,1,1,1]],
  J: [[1,0,0],[1,1,1]],
  L: [[0,0,1],[1,1,1]],
  O: [[1,1],[1,1]],
  S: [[0,1,1],[1,1,0]],
  T: [[0,1,0],[1,1,1]],
  Z: [[1,1,0],[0,1,1]]
};
const colors = { I:"cyan", J:"blue", L:"orange", O:"yellow", S:"green", T:"purple", Z:"red" };

let piece = null;

// 新しいピースを生成
function newPiece() {
  const keys = Object.keys(tetrominoes);
  const key = keys[Math.floor(Math.random()*keys.length)];
  const shape = tetrominoes[key];
  piece = { shape, x: Math.floor(COLS/2)-1, y: 0, color: colors[key] };
}

// 回転
function rotate(matrix) {
  return matrix[0].map((_,i) => matrix.map(row => row[i]).reverse());
}

// 衝突判定
function collide(px,py,shape) {
  for (let y=0; y<shape.length; y++) {
    for (let x=0; x<shape[y].length; x++) {
      if (shape[y][x] &&
        (board[py+y] && board[py+y][px+x]) !== 0) return true;
    }
  }
  return false;
}

// ピースを固定
function merge() {
  piece.shape.forEach((row, y) => {
    row.forEach((v, x) => {
      if (v) board[piece.y+y][piece.x+x] = piece.color;
    });
  });
}

// ライン消去
function clearLines() {
  board = board.filter(row => row.some(v => !v));
  while (board.length < ROWS) board.unshift(Array(COLS).fill(0));
}

// 描画
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 盤面
  for (let y=0; y<ROWS; y++) {
    for (let x=0; x<COLS; x++) {
      if (board[y][x]) {
        ctx.fillStyle = board[y][x];
        ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }
  // ピース
  if (piece) {
    ctx.fillStyle = piece.color;
    piece.shape.forEach((row,y) => {
      row.forEach((v,x) => {
        if (v) ctx.fillRect((piece.x+x)*BLOCK,(piece.y+y)*BLOCK,BLOCK,BLOCK);
      });
    });
  }
}

// ゲームループ
let dropCounter=0, dropInterval=500, lastTime=0;
function update(time=0) {
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval) {
    piece.y++;
    if (collide(piece.x,piece.y,piece.shape)) {
      piece.y--;
      merge();
      clearLines();
      newPiece();
      if (collide(piece.x,piece.y,piece.shape)) {
        alert("Game Over!");
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      }
    }
    dropCounter = 0;
  }
  draw();
  requestAnimationFrame(update);
}

// 入力
document.addEventListener("keydown", e => {
  if (!piece) return;
  if (e.key==="ArrowLeft" && !collide(piece.x-1,piece.y,piece.shape)) piece.x--;
  if (e.key==="ArrowRight" && !collide(piece.x+1,piece.y,piece.shape)) piece.x++;
  if (e.key==="ArrowDown") piece.y++;
  if (e.key===" ") { while (!collide(piece.x,piece.y+1,piece.shape)) piece.y++; }
  if (e.key==="ArrowUp") {
    const rotated = rotate(piece.shape);
    if (!collide(piece.x,piece.y,rotated)) piece.shape = rotated;
  }
});

newPiece();
update();
</script>
</body>
</html>
